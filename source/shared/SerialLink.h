/*
    SerialLink.h - Tools for CARRT3 communications over serial (UART) link
    between the RPI and Pico.  This file is shared by both the
    RPI and Pico code bases.  

    Copyright (c) 2025 Igor Mikolic-Torreira.  All right reserved.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


#ifndef SerialLink_h
#define SerialLink_h



#include <array>
#include <bit>
#include <cstdint>
#include <cstring>
#include <optional>




/*************************************************************************************************************
   
    Design challenge: Linux serial read functions and Pico serial (UART) read functions are radically
    different.  Linux read() doesn't block, returning 0 bytes read (or partial reads for multi-byte
    requests) and there is no function to "check" if there is data to read.  The Pico UART reading 
    function blocks until the requested data is all read -- which could potentially be forever if 
    here is a problem with the serial link.  However, Pico offers a function to check if there is 
    data available to read (but doesn't tell you how much).  
   
    CARRT serial comms work by sending a single byte that conveys the message type, followed by 0 or more 
    bytes that comprise the contents of the message.  So when reading the serial port checking to see if there
    is a a message, there may or may not be data, but if there is data, the initial data is always a single
    byte containing the message type.
   
    However, once we have that single byte (message type), we know all the other bytes are in "the queue".  
    This gives rise the following strategy for the design:
   
    1.  Create a special function, getMsgType(), to read the "first byte" of a message.  This function
        immediately returns if no data is available or with the "first byte (= msg type)" if there is
        data available.  Implement on RPi0 with an attempted read() of a single byte, returning either 
        "no data" or the one byte that is the MsgId.  Implement on Pico with a check of whether there 
        is data available to read, and if so a potentially blocking read of a single byte (which won't 
        actually block since we know there is at least one byte available to read).
    2.  All other reading functions "know" there is data "coming", so for these make repeated attempts
        to read the data, without actually blocking.  On RPi0, can implement this directly with the 
        linux read() function (which is non-blocking).  On Pico, we "fake it" by attempting to read 
        a single byte at a time with a (is data available, if so read a byte) until we read the 
        contents of the message.  We make repeated attempts, but there is a limit.
    3.  If we hit the limit of attempts, we decide the serial link is sick and bail out.
   
    So client's use of SerialLink is as follows:
   
    1.  Check the serial link for incoming messages by calling getMsgType() which either returns the 
        MsgId (a.k.a., message type) of the incoming message or std::nullopt (if no message to read).
    2.  Read the content of the message using any of the other reading functions, all of which make repeated
        attempts to read the required data, but will eventually throw an error.
   
    Note also:
   
    --  A common header defines the message contents (found in "shared/SerialMessages.h"), so RPi0 and Pico 
        are guaranteed to implement the same definition of the message contents.
   
    --  The code that actual reads/writes the contents of any message is generated by a common template 
        (see readIn() and sendOut() of template struct RawMessage in "SerialMessage.h").  This guarantees 
        that the implementation on both RPi0 and Pico will actually read and write all members of the 
        contents of a message.  
   
    This means the receiver should never be waiting to read a part of a message that the sender failed to 
    send.  Assuming of course that RPi0 and Pico are loaded with the same build version of their code.
        
**************************************************************************************************************/


// Forward declaration
enum class MsgId : std::uint8_t;


class SerialLink
{

public:

    // Abstract class that needs virtual destructor
    virtual ~SerialLink() = default;

    // Prevent copy, move, or assignment
    SerialLink( const SerialLink& ) = delete;
    SerialLink( SerialLink&& ) = delete;
    SerialLink& operator=( const SerialLink& ) = delete;
    SerialLink& operator=( SerialLink&& ) = delete;

    // Foundational functions, reading
    virtual std::optional<MsgId> getMsgType() = 0;
    virtual std::optional<std::uint8_t> getByte() = 0;
    virtual std::optional<std::uint32_t> get4Bytes() = 0;
    virtual bool get4Bytes( std::uint8_t c[4] ) = 0;

    // Foundational functions, writing 
    virtual void putByte( std::uint8_t c ) = 0;
    virtual void put4Bytes( const std::uint8_t c[4] ) = 0;


    // Reading functions
    std::optional<int> getInt();
    std::optional<std::uint32_t> getUInt32()            { return get4Bytes(); }
    std::optional<float> getFloat();

    // Reading overloaded functions
    std::optional<std::uint8_t> get( std::uint8_t )     { return getByte(); }
    std::optional<int> get( int )                       { return getInt(); }
    std::optional<std::uint32_t> get( std::uint32_t )   { return getUInt32(); }
    std::optional<float> get( float )                   { return getFloat(); }

    
    // Bulk functions
    virtual int getBytes( int nbr, std::uint8_t* buffer ) = 0;
    virtual int putBytes( int nbr, const std::uint8_t* buffer ) = 0;


    // Writing functions
    inline void putMsgType( char msg )
        { putByte( static_cast<std::uint8_t>( msg ) );}
    inline void putMsgType( std::uint8_t msg )  
        { putByte( msg ); }
    inline void put( char c )                   
        { putByte( c ); }
    inline void put( std::uint8_t c )           
        { putByte( c ); }
    inline void put( int i )                    
        { RawData r( i ); put4Bytes( r.c() ); }
    inline void put( std::uint32_t u )          
        { RawData r( u ); put4Bytes( r.c() ); }
    inline void put( float f )                 
        { RawData r( f ); put4Bytes( r.c() ); }


protected:

    // Only derived classes can create a SerialLink
    SerialLink() = default;     

#if 0  // Turn off, remove soonish
    union Transfer
    {
        std::uint8_t    c[4];
        int             i;
        std::uint32_t   u;
        float           f;
    };
#endif

    class RawData
    {
    public:
        using RawDataT = std::array<std::uint8_t, 4>;

        RawData() = default;
        RawData( std::uint8_t* cc )
            { c( cc ); }
        RawData( int ii )
            { i( ii ); }
        RawData( std::uint32_t uu )
            { u( uu ); }
        RawData( float ff )
            { f( ff ); }

        std::uint8_t* c()
            { return mRaw.data(); }

        void c( std::uint8_t* cc )
            { std::memcpy( mRaw.data(), cc, 4 ); }

        int i()
            { return std::bit_cast<int>( mRaw ); }
        void i( int ii )
            { mRaw = std::bit_cast<RawDataT>( ii ); }

        std::uint32_t u()
            { return std::bit_cast<std::uint32_t>( mRaw ); }
        void u( std::uint32_t uu )
            { mRaw = std::bit_cast<RawDataT>( uu ); }

        float f()
            { return std::bit_cast<float>( mRaw ); }
        void f( float ff )
            { mRaw = std::bit_cast<RawDataT>( ff ); }

    private:
        RawDataT    mRaw;
    };

private:

};



#endif // SerialLink_h
