

https://learn.adafruit.com/bno055-absolute-orientation-sensor-with-raspberry-pi-and-beaglebone-black/webgl-example#sensor-calibration



https://aiinsemi.com/post/Why%20Your%20BNO055%20Sensor%20is%20Giving%20Incorrect%20Data_%20Common%20Calibration%20Issues.html


https://forums.adafruit.com/viewtopic.php?f=25&t=108290&p=541754#p541754

by gammaburst Â» 16 Dec 2016 22:53
"sensor holds its default configuration P1" -- Do you mean that writing AXIS_REMAP_CONFIG and AXIS_REMAP_SIGN had no effect? Perhaps you are writing them at the wrong time - the Bosch documentation is sometimes vague and insufficient.

Here's my BNO055 startup procedure:
- assert RST
- wait one microsecond
- deassert RST
- wait 800 milliseconds
- (optional) write the two axis remap registers
- (optional) write my previously stored calibration profile into registers 0x55-0x6A
- write 0x0C (NDOF mode) into OPR_MODE register
- wait 10 milliseconds
- begin reading sensor and fusion data registers every 10 milliseconds.

Beware the BNO055 datasheet uses two spellings:
- AXIS_MAP_CONFIG and AXIS_MAP_SIGN
- AXIS_REMAP_CONFIG and AXIS_REMAP_SIGN.

Be sure you have the current BNO055 datasheet version 1.4.

Axises can be remaped only in OPERATION_MODE_CONFIG state.
Reading and writing calibration data is only possible in this state.


How are you testing your quaternion-to-euler conversion? Numbers via the serial port? 3D graphics display? Beware the bunny/Processing example is broken.

Remember to normalize the quaternion.

If you use other people's vector and quaternion equations, beware of different axes conventions. This gets confusing!

During my experiments with Adafruit's BNO055 library I used this code to convert quaternion to Euler. It's one of the fixes that I applied to the bunny/Processing example:

/* Convert quaternion to Euler, because BNO055 Euler data is broken */
  imu::Quaternion q = bno.getQuat();
  q.normalize();
  float temp = q.x();  q.x() = -q.y();  q.y() = temp;
  q.z() = -q.z();
  imu::Vector<3> euler = q.toEuler();
  Serial.print(F("Orientation: "));
  Serial.print(-180/M_PI * euler.x());  // heading, nose-right is positive, z-axis points up
  Serial.print(F(" "));
  Serial.print(-180/M_PI * euler.y());  // roll, rightwing-up is positive, y-axis points forward
  Serial.print(F(" "));
  Serial.print(-180/M_PI * euler.z());  // pitch, nose-down is positive, x-axis points right
  Serial.println(F(""));

I have also successfully used Wikipedia's info and equations:
https://en.wikipedia.org/wiki/Conversio ... Conversion

https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles#Quaternion_to_Euler_Angles_Conversion




https://forum.arduino.cc/t/convert-adafruit-bno055-quaternion-angles-to-euler-angles/399436/5

float yaw   = atan2(2.0f * (q[1] * q[2] + q[0] * q[3]), q[0] * q[0] + q[1] * q[1] - q[2] * q[2] - q[3] * q[3]);
float pitch = -asin(2.0f * (q[1] * q[3] - q[0] * q[2]));
float roll = atan2(2.0f * (q[0] * q[1] + q[2] * q[3]), q[0] * q[0] - q[1] * q[1] - q[2] * q[2] + q[3] * q[3]);[/quote]